{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientBulkWriteExecutor = void 0;\nconst client_bulk_write_cursor_1 = require(\"../../cursor/client_bulk_write_cursor\");\nconst error_1 = require(\"../../error\");\nconst write_concern_1 = require(\"../../write_concern\");\nconst execute_operation_1 = require(\"../execute_operation\");\nconst client_bulk_write_1 = require(\"./client_bulk_write\");\nconst command_builder_1 = require(\"./command_builder\");\nconst results_merger_1 = require(\"./results_merger\");\n/**\n * Responsible for executing a client bulk write.\n * @internal\n */\nclass ClientBulkWriteExecutor {\n  /**\n   * Instantiate the executor.\n   * @param client - The mongo client.\n   * @param operations - The user supplied bulk write models.\n   * @param options - The bulk write options.\n   */\n  constructor(client, operations, options) {\n    if (operations.length === 0) {\n      throw new error_1.MongoClientBulkWriteExecutionError('No client bulk write models were provided.');\n    }\n    this.client = client;\n    this.operations = operations;\n    this.options = {\n      ordered: true,\n      bypassDocumentValidation: false,\n      verboseResults: false,\n      ...options\n    };\n    // If no write concern was provided, we inherit one from the client.\n    if (!this.options.writeConcern) {\n      this.options.writeConcern = write_concern_1.WriteConcern.fromOptions(this.client.options);\n    }\n    if (this.options.writeConcern?.w === 0) {\n      if (this.options.verboseResults) {\n        throw new error_1.MongoInvalidArgumentError('Cannot request unacknowledged write concern and verbose results');\n      }\n      if (this.options.ordered) {\n        throw new error_1.MongoInvalidArgumentError('Cannot request unacknowledged write concern and ordered writes');\n      }\n    }\n  }\n  /**\n   * Execute the client bulk write. Will split commands into batches and exhaust the cursors\n   * for each, then merge the results into one.\n   * @returns The result.\n   */\n  async execute() {\n    // The command builder will take the user provided models and potential split the batch\n    // into multiple commands due to size.\n    const pkFactory = this.client.s.options.pkFactory;\n    const commandBuilder = new command_builder_1.ClientBulkWriteCommandBuilder(this.operations, this.options, pkFactory);\n    // Unacknowledged writes need to execute all batches and return { ok: 1}\n    if (this.options.writeConcern?.w === 0) {\n      while (commandBuilder.hasNextBatch()) {\n        const operation = new client_bulk_write_1.ClientBulkWriteOperation(commandBuilder, this.options);\n        await (0, execute_operation_1.executeOperation)(this.client, operation);\n      }\n      return results_merger_1.ClientBulkWriteResultsMerger.unacknowledged();\n    } else {\n      const resultsMerger = new results_merger_1.ClientBulkWriteResultsMerger(this.options);\n      // For each command will will create and exhaust a cursor for the results.\n      while (commandBuilder.hasNextBatch()) {\n        const cursor = new client_bulk_write_cursor_1.ClientBulkWriteCursor(this.client, commandBuilder, this.options);\n        try {\n          await resultsMerger.merge(cursor);\n        } catch (error) {\n          // Write concern errors are recorded in the writeConcernErrors field on MongoClientBulkWriteError.\n          // When a write concern error is encountered, it should not terminate execution of the bulk write\n          // for either ordered or unordered bulk writes. However, drivers MUST throw an exception at the end\n          // of execution if any write concern errors were observed.\n          if (error instanceof error_1.MongoServerError && !(error instanceof error_1.MongoClientBulkWriteError)) {\n            // Server side errors need to be wrapped inside a MongoClientBulkWriteError, where the root\n            // cause is the error property and a partial result is to be included.\n            const bulkWriteError = new error_1.MongoClientBulkWriteError({\n              message: 'Mongo client bulk write encountered an error during execution'\n            });\n            bulkWriteError.cause = error;\n            bulkWriteError.partialResult = resultsMerger.bulkWriteResult;\n            throw bulkWriteError;\n          } else {\n            // Client side errors are just thrown.\n            throw error;\n          }\n        }\n      }\n      // If we have write concern errors or unordered write errors at the end we throw.\n      if (resultsMerger.writeConcernErrors.length > 0 || resultsMerger.writeErrors.size > 0) {\n        const error = new error_1.MongoClientBulkWriteError({\n          message: 'Mongo client bulk write encountered errors during execution.'\n        });\n        error.writeConcernErrors = resultsMerger.writeConcernErrors;\n        error.writeErrors = resultsMerger.writeErrors;\n        error.partialResult = resultsMerger.bulkWriteResult;\n        throw error;\n      }\n      return resultsMerger.bulkWriteResult;\n    }\n  }\n}\nexports.ClientBulkWriteExecutor = ClientBulkWriteExecutor;","map":{"version":3,"names":["client_bulk_write_cursor_1","require","error_1","write_concern_1","execute_operation_1","client_bulk_write_1","command_builder_1","results_merger_1","ClientBulkWriteExecutor","constructor","client","operations","options","length","MongoClientBulkWriteExecutionError","ordered","bypassDocumentValidation","verboseResults","writeConcern","WriteConcern","fromOptions","w","MongoInvalidArgumentError","execute","pkFactory","s","commandBuilder","ClientBulkWriteCommandBuilder","hasNextBatch","operation","ClientBulkWriteOperation","executeOperation","ClientBulkWriteResultsMerger","unacknowledged","resultsMerger","cursor","ClientBulkWriteCursor","merge","error","MongoServerError","MongoClientBulkWriteError","bulkWriteError","message","cause","partialResult","bulkWriteResult","writeConcernErrors","writeErrors","size","exports"],"sources":["C:\\Users\\holla\\circus-website2\\node_modules\\mongodb\\src\\operations\\client_bulk_write\\executor.ts"],"sourcesContent":["import { type Document } from '../../bson';\nimport { ClientBulkWriteCursor } from '../../cursor/client_bulk_write_cursor';\nimport {\n  MongoClientBulkWriteError,\n  MongoClientBulkWriteExecutionError,\n  MongoInvalidArgumentError,\n  MongoServerError\n} from '../../error';\nimport { type MongoClient } from '../../mongo_client';\nimport { WriteConcern } from '../../write_concern';\nimport { executeOperation } from '../execute_operation';\nimport { ClientBulkWriteOperation } from './client_bulk_write';\nimport { ClientBulkWriteCommandBuilder } from './command_builder';\nimport {\n  type AnyClientBulkWriteModel,\n  type ClientBulkWriteOptions,\n  type ClientBulkWriteResult\n} from './common';\nimport { ClientBulkWriteResultsMerger } from './results_merger';\n\n/**\n * Responsible for executing a client bulk write.\n * @internal\n */\nexport class ClientBulkWriteExecutor {\n  private readonly client: MongoClient;\n  private readonly options: ClientBulkWriteOptions;\n  private readonly operations: ReadonlyArray<AnyClientBulkWriteModel<Document>>;\n\n  /**\n   * Instantiate the executor.\n   * @param client - The mongo client.\n   * @param operations - The user supplied bulk write models.\n   * @param options - The bulk write options.\n   */\n  constructor(\n    client: MongoClient,\n    operations: ReadonlyArray<AnyClientBulkWriteModel<Document>>,\n    options?: ClientBulkWriteOptions\n  ) {\n    if (operations.length === 0) {\n      throw new MongoClientBulkWriteExecutionError('No client bulk write models were provided.');\n    }\n\n    this.client = client;\n    this.operations = operations;\n    this.options = {\n      ordered: true,\n      bypassDocumentValidation: false,\n      verboseResults: false,\n      ...options\n    };\n\n    // If no write concern was provided, we inherit one from the client.\n    if (!this.options.writeConcern) {\n      this.options.writeConcern = WriteConcern.fromOptions(this.client.options);\n    }\n\n    if (this.options.writeConcern?.w === 0) {\n      if (this.options.verboseResults) {\n        throw new MongoInvalidArgumentError(\n          'Cannot request unacknowledged write concern and verbose results'\n        );\n      }\n\n      if (this.options.ordered) {\n        throw new MongoInvalidArgumentError(\n          'Cannot request unacknowledged write concern and ordered writes'\n        );\n      }\n    }\n  }\n\n  /**\n   * Execute the client bulk write. Will split commands into batches and exhaust the cursors\n   * for each, then merge the results into one.\n   * @returns The result.\n   */\n  async execute(): Promise<ClientBulkWriteResult> {\n    // The command builder will take the user provided models and potential split the batch\n    // into multiple commands due to size.\n    const pkFactory = this.client.s.options.pkFactory;\n    const commandBuilder = new ClientBulkWriteCommandBuilder(\n      this.operations,\n      this.options,\n      pkFactory\n    );\n    // Unacknowledged writes need to execute all batches and return { ok: 1}\n    if (this.options.writeConcern?.w === 0) {\n      while (commandBuilder.hasNextBatch()) {\n        const operation = new ClientBulkWriteOperation(commandBuilder, this.options);\n        await executeOperation(this.client, operation);\n      }\n      return ClientBulkWriteResultsMerger.unacknowledged();\n    } else {\n      const resultsMerger = new ClientBulkWriteResultsMerger(this.options);\n      // For each command will will create and exhaust a cursor for the results.\n      while (commandBuilder.hasNextBatch()) {\n        const cursor = new ClientBulkWriteCursor(this.client, commandBuilder, this.options);\n        try {\n          await resultsMerger.merge(cursor);\n        } catch (error) {\n          // Write concern errors are recorded in the writeConcernErrors field on MongoClientBulkWriteError.\n          // When a write concern error is encountered, it should not terminate execution of the bulk write\n          // for either ordered or unordered bulk writes. However, drivers MUST throw an exception at the end\n          // of execution if any write concern errors were observed.\n          if (error instanceof MongoServerError && !(error instanceof MongoClientBulkWriteError)) {\n            // Server side errors need to be wrapped inside a MongoClientBulkWriteError, where the root\n            // cause is the error property and a partial result is to be included.\n            const bulkWriteError = new MongoClientBulkWriteError({\n              message: 'Mongo client bulk write encountered an error during execution'\n            });\n            bulkWriteError.cause = error;\n            bulkWriteError.partialResult = resultsMerger.bulkWriteResult;\n            throw bulkWriteError;\n          } else {\n            // Client side errors are just thrown.\n            throw error;\n          }\n        }\n      }\n\n      // If we have write concern errors or unordered write errors at the end we throw.\n      if (resultsMerger.writeConcernErrors.length > 0 || resultsMerger.writeErrors.size > 0) {\n        const error = new MongoClientBulkWriteError({\n          message: 'Mongo client bulk write encountered errors during execution.'\n        });\n        error.writeConcernErrors = resultsMerger.writeConcernErrors;\n        error.writeErrors = resultsMerger.writeErrors;\n        error.partialResult = resultsMerger.bulkWriteResult;\n        throw error;\n      }\n\n      return resultsMerger.bulkWriteResult;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}